\chapter{Necessidade da Abstração de hardware}\label{cap:necessidade_abstr_hw}

O \textit{hardware} do robô pode ser implementado de várias formas, por exemplo, com diferentes componentes e subsistemas, desde que suas funcionalidades básicas sejam preservadas e deseja-se que a maior parte do \textit{firmware} seja independente das variações de implementações de \textit{hardware}, característica chamada de modularidade. Para isso, cria-se uma camada de abstração entre os dispositivos físicos e a lógica que os comanda, cada módulo do robô é visto apenas como uma interface. Qualquer alteração feita na implementação de um módulo não tornará necessária a modificação de nenhuma outra parte do \textit{firmware}, a menos que a interface tenha de ser modificada. Além disso, devido à SSL ser uma competição que almeja o avanço tecnológico na área de robótica, é interessante que o projeto possa continuar avançando independente das outras áreas, por isso quanto mais modular o trabalho, mais fácil se torna a realização de melhorias.

Os projetos da placa mãe, dos módulos de motor e do módulo de chute foram pensados com concepção modular justamente para que a abstração de \textit{hardware} pudesse ser a mais abrangente possível. Ao fazer o módulo de chute e os módulos dos motores separados da placa mãe podemos modificá-los sem ter quer alterar nenhuma outra parte do projeto. O que precisa ser mantido é a funcionalidade. Por exemplo: contanto que os módulos de motor recebam as informações necessárias da placa mãe e enviem as certas para os motores, não importa como este módulo foi contruído. O mesmo vale para a placa de chute e para o módulo de comunicação.

Abaixo, está descrito como os componentes tiveram sua funcionalidade abstraída.
O robô tem dois chutes diferentes, o alto e o baixo. Dentro de cada opção, pode-se ainda determinar a intensidade do chute. Logo, para que ele funcione, basta enviar um sinal indicando qual o chute a ser usado e um número indicando a intensidade.
Para o drible, é necessário apenas que o motor gire numa direção específica a uma certa velocidade, logo, basta que se envie um sinal PWM (\textit{Pulse Width Modulation} – modulação por largura de pulso). Da mesma forma que o drible, as rodas devem funcionar com sinal PWM, entretanto, o motor das rodas pode inverter seu sentido, portanto, são necessários dois sinais PWM, um para cada sentido. Para se enviar um sinal PWM são necessários o \textit{duty cycle} e a frequência. Assumindo a frequência constante para todos os sinais, o PWM fica em função apenas do \textit{duty cycle}. Como é utilizado um motor DC em cada roda, é necessário o uso de um encoder para se determinar sua velocidade de giro. Para tal, é preciso um contador de tempo, ou \textit{timer}, e saber o número de divisões em uma volta completa do encoder. Sabendo o tempo transcorrido e a diferença entre os valores lidos, calcula-se a velocidade de giro do motor.
O conversor analógico digital, ou ADC (\textit{Analog to Digital Converter} – conversor analógico para digital) lê uma tensão analógica e converte para uma representação digital. O funcionamento dos sensores depende da leitura de um sinal digital. No caso do sensor de presença da bola, que fica no drible, é enviado um pulso caso detecte algo.
A interface de SPI precisa apenas de funções para escrever um \textit{byte} ou um \textit{buffer} e funções para iniciar e terminar a transmissão. Como leitura e escrita ocorrem simultaneamente, para ler basta escrever algo e retornar o que o escravo enviou.
Quanto ao módulo de transmissão, basicamente, há as funções para transmitir pacotes e para verificar se há algum pacote recebido disponível para leitura.

Nota-se a interdependência entre os itens, por exemplo, tanto o motor das rodas como o drible utilizam sinais PWM, que por sua vez também está abstraído. Para utilizar sinais PWM para duas funções diferentes não é necessário alterar sua implementação.
Uma das aplicações disto no robô está no controle dos motores. Enquanto há camadas responsáveis por iniciar os encoders e os motores, há outra separada designada para usar os valores enviados por estas para realizar o controle de velocidades. Ressalta-se que nenhuma camada sabe o que acontece dentro da outra, sendo relevante para as demais somente o que elas recebem e enviam.

% Ramificação constante ou taxa constante

% vim: tw=80 et ts=2 sw=2 sts=2 ft=tex spelllang=pt_br,en
